#!/usr/bin/env python @ZL
# coding: utf-8

import platform, socket, re, uuid, json, psutil, logging, sys, ctypes
import pathlib, datetime, os, glob
import pandas as pd

class CIE_Converter:
    """A module to convert CIE spaces(CIE1976 <-> CIE1931)  
    Author: @ZL, 20200331

    It provides the following operations.
    - convert CIE1976 space coordiates(u', v') to CIE1931 space coorinates(x, y)
    - convert CIE1931 space coorinates(x, y) to CIE1976 space coordiates(u', v')

    Refer to the standards of CIE spaces on internet
    """
    def __init__(self, a, b, color_space):
        self.a = a
        self.b = b
        self.color_space = color_space

    def __repr__(self):
        if self.color_space == 'xy':
            return "xy->u\'v\', u\':{:.4f}, v\':{:.4f}".format(*self.converter())
        if self.color_space == 'dudv':
            return "u\'v\'->xy, x :{:.4f}, y: {:.4f}".format(*self.converter())
        else:
            return 'incorrect color space'

    def converter(self):
        def convert_dudv_to_xy(du, dv):
            """CIE1976 space(du,dv) to CIE1931 space(x,y) @ZL"""
            y = (3*dv)/(9*du/2 - 12*dv + 9)
            x = (du/dv)*9/4*y
            return x, y

        def convert_xy_to_dudv(x, y):
            """CIE1931 space(x,y) to CIE1976 space(du,dv) @ZL"""
            du = (4*x)/(12*y - 2*x + 3)
            dv = (9*y)/(12*y - 2*x + 3)
            return du, dv

        if self.color_space == 'xy':
            return convert_xy_to_dudv(self.a, self.b)
        if self.color_space == 'dudv':
            return convert_dudv_to_xy(self.a, self.b)
        else:
            return

def getSystemInfo():
    """a function retrieves system info

    :return: None
    :rtype: None
    """
    try:
        info = {}
        info['platform']         = platform.system()
        info['platform-release'] = platform.release()
        info['platform-version'] = platform.version()
        info['architecture']     = platform.machine()
        info['hostname']         = socket.gethostname()
        info['ip-address']       = socket.gethostbyname(socket.gethostname())
        info['mac-address']      = ':'.join(re.findall('..', '%012x' % uuid.getnode()))
        info['processor']        = platform.processor()
        info['ram']              = str(round(psutil.virtual_memory().total / (1024.0 **3)))+" GB"
        info['python -V']        = sys.version
        info['screensize']       = ctypes.windll.user32.GetSystemMetrics(0), ctypes.windll.user32.GetSystemMetrics(1)
        return json.dumps(info)
    except Exception as e:
        logging.exception(e)

def is_expired(expired_date: str='Dec 1 2020 8:00AM'):
    """a function decides where current date time ixpired

    :param expired_date: a datetime expired, defaults to 'Dec 1 2020 8:00AM'
    :type expired_date: str, optional
    :return: return true if expired or false if not
    :rtype: bool
    """
    ed = datetime.datetime.strptime(expired_date,'%b %d %Y %I:%M%p')
    now = datetime.datetime.now()
    return (now - ed) > datetime.timedelta(days=1)

def is_outdated(file_path: str, days: int=1):
    mtime = pathlib.Path(file_path).stat().st_mtime
    mtime = datetime.datetime.fromtimestamp(mtime)
    now = datetime.datetime.now()
    return (now - mtime) > datetime.timedelta(days=days)

def merge_LCM_log(fd_path: str):
    """a function merges all LCM log files into one csv file.

    :param fd_path: a folder that stores source csv files
    :type fd_path: the folder path
    """
    if os.path.isdir(fd_path):
        files = glob.glob(os.path.join(fd_path, "*.csv"))
        files.sort()
        n = 84
        col_names = ['h' + str(i) for i in range(n)]
        big_df = pd.concat((pd.read_csv(f, header=None, usecols=range(n), names=col_names, engine='python') \
                                        for f in files), ignore_index=True, sort=False)

        big_df = big_df.dropna(subset=['h' + str(n - 1)])
        fn = os.path.join(fd_path, 'all_LCM_merged.xlsx')
        big_df.to_excel(fn)

def merge_SET_log(fd_path: str):
    """a function merges all SET log files into one csv file.

    :param fd_path: a folder that stores source csv files
    :type fd_path: the folder path
    """
    if os.path.isdir(fd_path):
        files = glob.glob(os.path.join(fd_path, "*.csv"))
        files.sort()
        big_df = pd.concat((pd.read_csv(f, skiprows=1, engine='python') for f in files), ignore_index=True, sort=False)
        big_df = big_df[pd.notnull(big_df['STATE'])]
        #<~ combine all date and save as xl file
        fn = os.path.join(fd_path, 'all_SET_merged.xlsx')
        big_df.to_excel(fn)